#Lege eine neue Nginx-Konfigurationsdatei an. Es ist üblich, diese in einem separaten Ordner unter /etc/nginx/conf.d/ zu speichern, um die Übersichtlichkeit zu wahren. Nennen wir sie beispielsweise doh-gateway.conf:
#(DoT-Gateway derzeit direkt in der nginx.conf....
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



upstream dns_servers {
    server 127.0.0.1:53; # Hier die IP-Adresse und Port deines nachgelagerten DNS-Servers eintragen
    # Du kannst hier auch mehrere DNS-Server hinzufügen, z.B.:
    # server 192.168.1.10:53;
    # server [2001:db8::1]:53; # IPv6-Adresse
}

server {
    listen 443 ssl http2; # Port, auf dem der DoH-Gateway lauscht (kann angepasst werden)
    listen [::]:443 http2;

    server_name doh.example.com; # Ein interner oder externer Hostname

    ssl_certificate /etc/ssl/certs/dein_zertifikat.crt; # Pfad zu deinem Zertifikat
    ssl_certificate_key /etc/ssl/private/dein_privater_schlüssel.key; # Pfad zu deinem privaten Schlüssel

    ssl_protocols TLSv1.2 TLSv1.3; # Empfohlene TLS-Protokolle
    ssl_prefer_server_ciphers on;
    ssl_ciphers 'ECDHE+AESGCM:CHACHA20'; # Moderne Cipher Suites
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 1.1.1.1 8.8.8.8 valid=300s; # Öffentliche Resolver für OCSP Stapling
    resolver_timeout 5s;

    location /dns-query {
        resolver 127.0.0.1 valid=5s; # Lokaler Resolver für Nginx (kann angepasst werden)
        resolver_timeout 2s;

        proxy_pass http://dns_servers/resolve;
        proxy_method POST;
        proxy_set_header Content-Type application/dns-message;
        proxy_set_header Accept application/dns-message;
        proxy_set_header Content-Length $request_body_content_length;
        proxy_pass_request_body off;
        proxy_buffering off;
        proxy_request_buffering off;
    }

    location / {
        return 404; # Alle anderen Anfragen ablehnen
    }
}



#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#Erläuterungen zur Konfiguration:

#upstream dns_servers: Definiert eine Gruppe von Upstream-DNS-Servern, an die die DNS-Anfragen weitergeleitet werden. Hier musst du die IP-Adresse und den Port deines tatsächlichen DNS-Servers eintragen
#(in diesem Beispiel 127.0.0.1:53, was auf den lokalen Rechner deutet, falls dort ein DNS-Server läuft). Du kannst hier auch mehrere Server für Redundanz hinzufügen.

#server: Definiert den virtuellen Server für den DoH-Gateway.

#listen 443 ssl http2;: Nginx lauscht nun auf Port 443 und aktiviert SSL sowie HTTP/2.

#listen [::]:443 http2;: Entspricht der vorherigen Zeile, aber für IPv6.

#server_name doh.example.com;: Ein optionaler Servername. Dieser ist nützlich, wenn du mehrere virtuelle Hosts auf demselben Nginx-Server betreibst.

#ssl_certificate /etc/ssl/certs/dein_zertifikat.crt;: Hier musst du den absoluten Pfad zu deiner Zertifikatsdatei angeben.

#ssl_certificate_key /etc/ssl/private/dein_privater_schlüssel.key;: Hier musst du den absoluten Pfad zu deiner privaten Schlüsseldatei angeben. Stelle sicher, dass diese Datei nur für den root-Benutzer lesbar ist.

#ssl_protocols TLSv1.2 TLSv1.3;: Definiert die erlaubten TLS-Protokolle. Es wird dringend empfohlen, ältere, unsichere Protokolle wie TLSv1 und TLSv1.1 zu deaktivieren.

#ssl_prefer_server_ciphers on;: Weist den Server an, die in der ssl_ciphers-Direktive definierte Reihenfolge der Cipher Suites zu bevorzugen.

#ssl_ciphers 'ECDHE+AESGCM:CHACHA20';: Legt die zu verwendenden Cipher Suites fest. Diese Auswahl bietet eine gute Balance zwischen Sicherheit und Leistung. Du kannst diese Liste nach Bedarf anpassen.

#ssl_session_cache shared:SSL:10m;: Aktiviert einen Shared Session Cache, um die Wiederaufnahme von TLS-Sitzungen zu beschleunigen. 10m gibt die Größe des Caches an (ca. 10 Megabyte).

#ssl_session_timeout 10m;: Legt die Gültigkeitsdauer der TLS-Sitzungen im Cache fest (10 Minuten).

#ssl_stapling on;: Aktiviert OCSP Stapling. Der Server fragt regelmäßig den OCSP-Responder der Zertifizierungsstelle nach dem Gültigkeitsstatus seines Zertifikats und sendet diese Information (das "Staple") mit dem TLS-Handshake
#an den Client. Dies verbessert die Leistung und den Datenschutz, da der Client den OCSP-Responder nicht selbst kontaktieren muss.

#ssl_stapling_verify on;: Aktiviert die Überprüfung der OCSP-Antwort.

#resolver 1.1.1.1 8.8.8.8 valid=300s;: Für OCSP Stapling benötigt Nginx einen vertrauenswürdigen DNS-Resolver, um den OCSP-Responder der CA zu erreichen. Hier werden die öffentlichen Resolver von Cloudflare und Google verwendet.

#resolver_timeout 5s;: Setzt ein Timeout für die DNS-Auflösung des OCSP-Responders.

#location /dns-query: Definiert den Pfad für die DoH-Anfragen. Clients senden ihre DNS-Anfragen als HTTP POST-Requests an diesen Pfad.

#resolver 127.0.0.1 valid=5s;: Nginx benötigt einen eigenen DNS-Resolver, um den Hostnamen in der proxy_pass-Direktive aufzulösen. Hier wird der lokale Resolver verwendet. valid=5s gibt an, wie lange die Auflösung gecacht wird.

#resolver_timeout 2s;: Setzt ein Timeout für die DNS-Auflösung durch Nginx.

#proxy_pass http://dns_servers/resolve;: Leitet die Anfrage an die in der upstream-Gruppe definierten DNS-Server weiter. Der Pfad /resolve ist hier intern und wird von Nginx verwendet, um die DNS-Anfrage zu verarbeiten.

#proxy_method POST;: Stellt sicher, dass die Anfrage als HTTP POST weitergeleitet wird (wie es für DoH üblich ist).

#proxy_set_header Content-Type application/dns-message;: Setzt den korrekten Content-Type-Header für die DNS-Nachricht.

#proxy_set_header Accept application/dns-message;: Setzt den Accept-Header, um anzuzeigen, dass der Client eine DNS-Nachricht erwartet.

#proxy_set_header Content-Length $request_body_content_length;: Überträgt die Länge des Anfragekörpers.

#proxy_pass_request_body off;: Deaktiviert das automatische Senden des Anfragekörpers, da wir ihn manuell weiterleiten.

#proxy_buffering off; und proxy_request_buffering off;: Deaktivieren das Buffering, um eine direkte Weiterleitung der DNS-Nachrichten zu gewährleisten.
  
#location /: Leitet alle anderen Anfragen mit einem HTTP 404 (Not Found) Fehler ab.

